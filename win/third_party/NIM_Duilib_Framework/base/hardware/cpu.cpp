// Copyright (c) 2011, NetEase Inc. All rights reserved.
//
// Author: rl
// Date: 2011/6/6
//
// cpu description
/*
 *
 *	Author		rl
 *	Date		2011-06-06
 *	Copyright	Hangzhou, Netease Inc.
 *	Brief		cpu description
 *
 */

#include "cpu.h"
#include <string.h>

#if defined(ARCH_CPU_X86_FAMILY)
#if defined(COMPILER_MSVC)
#include <intrin.h>
#endif
#endif


namespace nbase
{

CPU::CPU()
	: type_(0),
	family_(0),
	model_(0),
	stepping_(0),
	ext_model_(0),
	ext_family_(0),
	has_mmx_(false),
	has_sse_(false),
	has_sse2_(false),
	has_sse3_(false),
	has_ssse3_(false),
	has_sse41_(false),
	has_sse42_(false),
	cpu_vendor_("unknown")
{
		Initialize();
}

#if defined(ARCH_CPU_X86_FAMILY)
#ifndef COMPILER_MSVC

#if defined(__pic__) && defined(__i386__)

void __cpuid(int cpu_info[4], int info_type)
{
	__asm__ volatile (
		"mov %%ebx, %%edi\n"
		"cpuid\n"
		"xchg %%edi, %%ebx\n"
		: "=a"(cpu_info[0]), "=D"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
		: "a"(info_type)
		);
}

void __cpuidex(int cpu_info[4], int info_type, int info_index)
{
	__asm__ volatile (
		"mov %%ebx, %%edi\n"
		"cpuid\n"
		"xchg %%edi, %%ebx\n"
		: "=a"(cpu_info[0]), "=D"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
		: "a"(info_type), "c"(info_index)
		);
}

#else

void __cpuid(int cpu_info[4], int info_type)
{
	__asm__ volatile (
		"cpuid \n\t"
		: "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
		: "a"(info_type)
		);
}

void __cpuidex(int cpu_info[4], int info_type, int info_index)
{
	__asm__ volatile (
		"cpuid \n\t"
		: "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
		: "a"(info_type), "c"(info_index)
		);
}

#endif
#endif  // COMPILER_MSVC
#endif  // ARCH_CPU_X86_FAMILY

void CPU::Initialize()
{
#if defined(ARCH_CPU_X86_FAMILY)
	int cpu_info[4] = {-1};
	char cpu_string[0x20];

	// __cpuid with an InfoType argument of 0 returns the number of
	// valid Ids in CPUInfo[0] and the CPU identification string in
	// the other three array elements. The CPU identification string is
	// not in linear order. The code below arranges the information
	// in a human readable form.
	//
	// More info can be found here:
	// http://msdn.microsoft.com/en-us/library/hskdteyh.aspx
	__cpuid(cpu_info, 0);
	int num_ids = cpu_info[0];
	memset(cpu_string, 0, sizeof(cpu_string));
	*(reinterpret_cast<int*>(cpu_string)) = cpu_info[1];
	*(reinterpret_cast<int*>(cpu_string+4)) = cpu_info[3];
	*(reinterpret_cast<int*>(cpu_string+8)) = cpu_info[2];

	// Interpret CPU feature information.
	if (num_ids > 0)
	{
		__cpuid(cpu_info, 1);
		stepping_   = cpu_info[0] & 0xf;
		model_      = ((cpu_info[0] >> 4) & 0xf) + ((cpu_info[0] >> 12) & 0xf0);
		family_     = (cpu_info[0] >> 8) & 0xf;
		type_       = (cpu_info[0] >> 12) & 0x3;
		ext_model_  = (cpu_info[0] >> 16) & 0xf;
		ext_family_ = (cpu_info[0] >> 20) & 0xff;
		cpu_vendor_ = cpu_string;
		has_mmx_    = (cpu_info[3] & 0x00800000) != 0;
		has_sse_    = (cpu_info[3] & 0x02000000) != 0;
		has_sse2_   = (cpu_info[3] & 0x04000000) != 0;
		has_sse3_   = (cpu_info[2] & 0x00000001) != 0;
		has_ssse3_  = (cpu_info[2] & 0x00000200) != 0;
		has_sse41_  = (cpu_info[2] & 0x00080000) != 0;
		has_sse42_  = (cpu_info[2] & 0x00100000) != 0;
	}
#endif
}

}  // namespace nbase
